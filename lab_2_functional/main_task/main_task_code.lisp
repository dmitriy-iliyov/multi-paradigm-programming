(defun values-by-random (size &optional (result '()))
  (if (zerop size)
      result
      (values-by-random (1- size) (cons (random 100) result))))

(defun sort-list (array)
  (sort (subseq array 0 (length array)) '<))

(defun set-alphabet (alphabet-power &optional (index 0) (alphabet '()))
  (if (< index alphabet-power)
      (set-alphabet alphabet-power (1+ index) (cons (string (code-char (+ (char-code #\A) index))) alphabet))
      (reverse alphabet)))

(defun cut-to-intervals (sorted-array alphabet-power &optional (i 0) (matrix-interval '()))
  (if (= i alphabet-power)
      (reverse matrix-interval)
      (let* ((interval-width (/ (- (elt sorted-array (1- (length sorted-array))) (elt sorted-array 0)) (- alphabet-power 1)))
             (a (+ (elt sorted-array 0) (* i interval-width)))
             (b (+ (elt sorted-array 0) (* (1+ i) interval-width)))
             (new-interval (list a b)))
        (cut-to-intervals sorted-array alphabet-power (1+ i) (cons new-interval matrix-interval)))))

(defun cut-to-intervals-v2 (sorted-array alphabet-power)
  (let* ((n (length sorted-array))
         (interval-width (/ n alphabet-power)))
    (loop for i from 0 below alphabet-power
          for a = (* i interval-width)
          for b = (* (1+ i) interval-width)
          collect (list (elt sorted-array (min (floor a) (1- n)))
                        (elt sorted-array (min (floor b) (1- n)))))))

(defun to-char-list (start-list intervals alphabet)
  (let ((char-list (make-list (length start-list))))
    (dotimes (i (length start-list))
      (dotimes (j (length alphabet))
        (let ((a (nth 0 (nth j intervals)))
              (b (nth 1 (nth j intervals))))
          (when (and (<= a (nth i start-list) b))
            (setf (nth i char-list) (nth j alphabet))))))
    char-list))

(defun find-index (a char-list &optional (index 0))
  (if (null char-list)
      nil
      (if (and (characterp a) (stringp (car char-list)) (string= a (car char-list)))
          index
          (find-index a (cdr char-list) (1+ index)))))

(defun make-result-matrix (char-list alphabet)
  (let* ((alphabet-power (length alphabet))
         (result-matrix (make-list alphabet-power :initial-element (make-list alphabet-power :initial-element 0))))
    (dotimes (i (1- (length char-list)))
      (let* ((current-index (find-index (nth i char-list) alphabet))
             (next-index (find-index (nth (1+ i) char-list) alphabet)))
        (when (and current-index next-index)
          (incf (nth next-index (nth current-index result-matrix))))))
    result-matrix))

(defun print-matrix (matrix)
  (dolist (row matrix)
    (dolist (element row)
      (format t "~a " element))
    (format t "~%")))

(defun main (size alphabet-power)
  (let ((start-list (values-by-random size))
        (alphabet (set-alphabet alphabet-power)))
    (let ((sorted-list (sort-list start-list)))
      (print "start list")
      (print start-list)
      (print "sorted list")
      (print sorted-list)
      (print "alphabet")
      (print alphabet)
      (format t "~%")
      (let ((intervals (cut-to-intervals sorted-list alphabet-power)))
        (dolist (interval intervals)
          (format t "Interval: [~f, ~f]~%" (first interval) (second interval)))
        (let ((char-list (to-char-list start-list intervals alphabet)))
          (format t "~A~%" char-list)
          (let ((result-matrix (make-result-matrix char-list alphabet)))
            (print-matrix result-matrix)))))))
        


(main 10 4)