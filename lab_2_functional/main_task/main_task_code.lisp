(defun values-by-random (size &optional (result '()))
  (if (zerop size)
      result
      (values-by-random (1- size) (cons (random 100) result))))

(defun sort-list (array)
  (sort (subseq array 0 (length array)) '<))

(defun set-alphabet (alphabet-power &optional (index 0) (alphabet '()))
  (if (< index alphabet-power)
      (progn
        (set-alphabet alphabet-power (1+ index) (cons (string (code-char (+ (char-code #\A) index))) alphabet)))
      (reverse alphabet)))

(defun cut-to-intervals (sorted-array alphabet-power &optional (i 0) (matrix-interval '()))
  (if (= i alphabet-power)
      (reverse matrix-interval)
      (let* ((interval-width (/ (- (elt sorted-array (1- (length sorted-array))) (elt sorted-array 0)) (- alphabet-power 1)))
             (a (+ (elt sorted-array 0) (* i interval-width)))
             (b (+ (elt sorted-array 0) (* (1+ i) interval-width)))
             (new-interval (list a b)))
        (cut-to-intervals sorted-array alphabet-power (1+ i) (cons new-interval matrix-interval)))))

(defun cut-to-intervals-v2 (sorted-array alphabet-power)
  (let* ((n (length sorted-array))
         (interval-width (/ n alphabet-power)))
    (loop for i from 0 below alphabet-power
          for a = (* i interval-width)
          for b = (* (1+ i) interval-width)
          collect (list (elt sorted-array (min (floor a) (1- n)))
                        (elt sorted-array (min (floor b) (1- n)))))))

(defun to-char-list (start-list intervals alphabet)
  (let ((char-list (make-list (length start-list))))
    (dotimes (i (length start-list))
      (let ((current-number (nth i start-list)))
        (dotimes (j (length alphabet))
          (let ((a (nth 0 (nth j intervals)))
                (b (nth 1 (nth j intervals)))
                (current-char (nth j alphabet)))
            (when (and (<= a current-number b))
              (setf (nth i char-list) current-char))))))
    char-list))


(defun find-index (element lst &optional (index 0))
  (cond ((null lst) nil)
        ((eql element (car lst)) index)
        (t (find-index element (cdr lst) (+ index 1)))))

(defun make-result-matrix (char-list alphabet)
  (let* ((alphabet-power (length alphabet))
         (result-matrix (make-array (list alphabet-power alphabet-power) :initial-element 0)))
    (loop for i below (1- (length char-list))
          for current-char = (nth i char-list)
          for next-char = (if (< (1+ i) (length char-list)) (nth (1+ i) char-list) nil)
          do (let* ((current-index (find-index current-char alphabet))
                    (next-index (find-index next-char alphabet)))
               (when (and current-index next-index)
                 (incf (aref result-matrix next-index current-index)))))
    result-matrix))

(defun print-matrix (matrix)
  (loop for i below (array-dimension matrix 0)
        do (loop for j below (array-dimension matrix 1)
                 do (format t "~a " (aref matrix i j)))
           (format t "~%")))

(defun main (size alphabet-power)
  (let ((start-list (values-by-random size))
        (alphabet (set-alphabet alphabet-power)))
    (let ((sorted-list (sort-list start-list)))
      (print "start list")
      (print start-list)
      (print "sorted list")
      (print sorted-list)
      (print "alphabet")
      (print alphabet)
      (format t "~%")
      (let ((intervals (cut-to-intervals sorted-list alphabet-power)))
        (dolist (interval intervals)
          (format t "Interval: [~f, ~f]~%" (first interval) (second interval)))
        (let ((char-list (to-char-list start-list intervals alphabet)))
          (format t "~A~%" char-list)
          (let ((result-matrix (make-result-matrix char-list alphabet)))
            (print-matrix result-matrix)))))))
        

(main 4 4)
